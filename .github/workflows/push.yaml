name: Branch Push
on: push
jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      landing: ${{ steps.filter.outputs.landing }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            landing:
              - 'landing/**'
              - '!landing/README.md'
            backend:
              - 'backend/**'
              - '!backend/env.example'

  convert-branch-name:
    needs: changes
    name: Convert Branch Name
    runs-on: ubuntu-latest
    if: ${{ needs.changes.outputs.backend == 'true' }}
    outputs:
      name: ${{ steps.convert.outputs.name }}
    steps:
      - id: convert
        env:
          BRANCH_NAME: "${{ github.head_ref || github.ref_name }}"
        run: |
          output=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed -E 's/^-+|-+$//g')
          echo "name=$output" >> $GITHUB_OUTPUT

  build-backend:
    needs: convert-branch-name
    name: Build Backend
    runs-on: ubuntu-latest
    if: ${{ needs.changes.outputs.backend == 'true' }}
    env:
      BRANCH_NAME: ${{needs.convert-branch-name.outputs.name}}
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build image
        run: cd backend && make docker
      - name: Push image with commit sha
        run: cd backend && make docker-push TAG=$BRANCH_NAME-$(git rev-parse --short "$GITHUB_SHA")
      - name: Push image with latest tag
        run: >-
          if [[ $BRANCH_NAME == "main" ]]; then
            cd backend && make docker-push TAG=latest
          else
            cd backend && make docker-push TAG=$BRANCH_NAME-latest
          fi

  build-landing:
    needs: convert-branch-name
    name: Build Landing
    runs-on: ubuntu-latest
    if: ${{ needs.changes.outputs.landing == 'true' }}
    env:
      BRANCH_NAME: ${{needs.convert-branch-name.outputs.name}}
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build image
        run: cd landing && make build
      - name: Push image with commit sha
        run: cd landing && make docker-push TAG=$BRANCH_NAME-$(git rev-parse --short "$GITHUB_SHA")
      - name: Push image with latest tag
        run: >-
          if [[ $BRANCH_NAME == "main" ]]; then
            cd landing && make docker-push TAG=latest
          else
            cd landing && make docker-push TAG=$BRANCH_NAME-latest
          fi

  deploy-backend:
    needs: [build-backend, convert-branch-name]
    name: Create Backend Deployment
    if: ${{ needs.changes.outputs.backend == 'true' }}
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{needs.convert-branch-name.outputs.name}}
      REGISTRY: ${{ vars.DOCKER_REGISTRY }}
    steps:
      - name: Create/Update Backend Deployment
        if: ${{ needs.changes.outputs.backend == 'true' }}
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          envs: BRANCH_NAME,REGISTRY
          script: |
            if [[ $BRANCH_NAME == "main" ]]; then
              export NAMESPACE="boshi";
              export SUBDOMAIN="boshi"
              export TAG="latest";
            else
              export NAMESPACE="$BRANCH_NAME";
              export SUBDOMAIN="$BRANCH_NAME-boshi";
              export TAG="$BRANCH_NAME-latest";
            fi

            if kubectl get namespace $NAMESPACE >/dev/null 2>&1; then
              kubectl rollout restart deployment boshi-backend -n $NAMESPACE
            else
              kubectl create namespace $NAMESPACE
              kubectl create deployment boshi-backend --image=$REGISTRY/boshi-backend:$TAG --port=80 -n $NAMESPACE
              kubectl expose deployment boshi-backend --name=boshi-backend-svc --port=80 --target-port=80 --type=ClusterIP -n $NAMESPACE
              kubectl create ingress ingress --annotation cert-manager.io/cluster-issuer="letsencrypt-prod" --class=nginx --rule="$SUBDOMAIN.deguzman.cloud/api/*=boshi-backend-svc:80,tls=boshi-tls" --rule="$SUBDOMAIN.deguzman.cloud/oauth/*=boshi-backend-svc:80,tls=boshi-tls" -n $NAMESPACE
            fi

  deploy-landing:
    needs: [build-landing, convert-branch-name]
    name: Create/Update Landing Deployment
    if: ${{ needs.changes.outputs.landing == 'true' }}
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{needs.convert-branch-name.outputs.name}}
      REGISTRY: ${{ vars.DOCKER_REGISTRY }}
    steps:
      - uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          envs: BRANCH_NAME,REGISTRY
          script: |
            if [[ $BRANCH_NAME == "main" ]]; then
              export NAMESPACE="boshi";
              export SUBDOMAIN="boshi-app";
              export TAG="latest";
            else
              export NAMESPACE="boshi-$BRANCH_NAME";
              export SUBDOMAIN="$BRANCH_NAME-boshi-app";
              export TAG="$BRANCH_NAME-latest";
            fi

            if kubectl get deployment boshi-landing -n $NAMESPACE $1 >/dev/null 2>&1; then
              kubectl rollout restart deployment boshi-landing -n $NAMESPACE
            else
                kubectl create namespace $NAMESPACE
                kubectl create deployment boshi-landing --image=$REGISTRY/boshi-landing:$TAG --port=3000 -n $NAMESPACE
                kubectl expose deployment boshi-landing --name=boshi-landing-svc --port=80 --target-port=3000 --type=ClusterIP -n $NAMESPACE
                kubectl create ingress landing-ingress --annotation cert-manager.io/cluster-issuer="letsencrypt-prod" --class=nginx --rule="$SUBDOMAIN.deguzman.cloud/*=boshi-landing-svc:80,tls=boshi-landing-tls" -n $NAMESPACE
            fi
