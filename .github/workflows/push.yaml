name: Branch Push
on: push
jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      landing: ${{ steps.filter.outputs.landing }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            landing:
              - 'landing/**'
              - '!landing/README.md'
            backend:
              - 'backend/**'
              - '!backend/env.example'

  get-build-info:
    needs: changes
    name: Get Build Info
    runs-on: ubuntu-latest
    if: ${{ needs.changes.outputs.backend == 'true' || needs.changes.outputs.landing == 'true' }}
    outputs:
      name: ${{ steps.convert.outputs.name }}
      commit-id: ${{ steps.convert.outputs.commit-id }}
    steps:
      - uses: actions/checkout@v4
      - id: convert
        env:
          BRANCH_NAME: "${{ github.head_ref || github.ref_name }}"
        run: |
          output=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed -E 's/^-+|-+$//g')
          echo "name=$output" >> $GITHUB_OUTPUT
          echo "commit-id=$(git rev-parse --short "$GITHUB_SHA") >> $GITHUB_OUTPUT"

  build:
    needs: [changes, get-build-info]
    name: Build Images
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{needs.get-build-info.outputs.name}}
      COMMIT_ID: ${{needs.get-build-info.outputs.commit-id}}
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build Backend
        if: ${{ needs.changes.outputs.backend == 'true' }}
        run: |
          echo "Building backend..."
          cd backend && make docker

          echo "Pushing images..."
          if [[ $BRANCH_NAME == "main" ]]; then
            make docker-push TAG=$COMMIT_ID
            make docker-push TAG=latest
          else
            make docker-push TAG=$BRANCH_NAME-$COMMIT_ID
            make docker-push TAG=$BRANCH_NAME-latest
          fi
      - name: Build Landing
        if: ${{ needs.changes.outputs.landing == 'true' }}
        run: |
          echo "Building Landing"
          cd landing && make docker

          echo "Push images"
          if [[ $BRANCH_NAME == "main" ]]; then
            make docker-push TAG=$COMMIT_ID
            make docker-push TAG=latest
          else
            make docker-push TAG=$BRANCH_NAME-$COMMIT_ID
            make docker-push TAG=$BRANCH_NAME-latest
          fi

  deploy:
    needs: [changes, build, get-build-info]
    name: Deploy Images
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{needs.get-build-info.outputs.name}}
      REGISTRY: ${{ vars.DOCKER_REGISTRY }}
      COMMIT_ID: ${{needs.get-build-info.outputs.commit-id}}
    steps:
      - name: Create/Update Backend Deployment
        if: ${{ needs.changes.outputs.backend == 'true' }}
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          envs: BRANCH_NAME,REGISTRY
          script: |
            if [[ $BRANCH_NAME == "main" ]]; then
              export NAMESPACE="boshi";
              export SUBDOMAIN="boshi"
              export TAG="$main-COMMIT_ID";
            else
              export NAMESPACE="$BRANCH_NAME";
              export SUBDOMAIN="$BRANCH_NAME-boshi";
              export TAG="$BRANCH_NAME-$COMMIT_ID";
            fi

            if kubectl get namespace $NAMESPACE >/dev/null 2>&1; then
              kubectl rollout restart deployment boshi-backend -n $NAMESPACE
            else
              kubectl create namespace $NAMESPACE
              kubectl create deployment boshi-backend --image=$REGISTRY/boshi-backend:$TAG --port=80 -n $NAMESPACE
              kubectl expose deployment boshi-backend --name=boshi-backend-svc --port=80 --target-port=80 --type=ClusterIP -n $NAMESPACE
              kubectl create ingress ingress --annotation cert-manager.io/cluster-issuer="letsencrypt-prod" --class=nginx --rule="$SUBDOMAIN.deguzman.cloud/api/*=boshi-backend-svc:80,tls=boshi-tls" --rule="$SUBDOMAIN.deguzman.cloud/oauth/*=boshi-backend-svc:80,tls=boshi-tls" -n $NAMESPACE
            fi
      - name: Create/Update Landing Deployment
        if: ${{ needs.changes.outputs.landing == 'true' }}
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          envs: BRANCH_NAME,REGISTRY
          script: |
            if [[ $BRANCH_NAME == "main" ]]; then
              export NAMESPACE="boshi";
              export SUBDOMAIN="boshi-app";
              export TAG="latest";
            else
              export NAMESPACE="boshi-$BRANCH_NAME";
              export SUBDOMAIN="$BRANCH_NAME-boshi-app";
              export TAG="$BRANCH_NAME-latest";
            fi

            if kubectl get deployment boshi-landing -n $NAMESPACE $1 >/dev/null 2>&1; then
              kubectl rollout restart deployment boshi-landing -n $NAMESPACE
            else
                kubectl create namespace $NAMESPACE
                kubectl create deployment boshi-landing --image=$REGISTRY/boshi-landing:$TAG --port=3000 -n $NAMESPACE
                kubectl expose deployment boshi-landing --name=boshi-landing-svc --port=80 --target-port=3000 --type=ClusterIP -n $NAMESPACE
                kubectl create ingress landing-ingress --annotation cert-manager.io/cluster-issuer="letsencrypt-prod" --class=nginx --rule="$SUBDOMAIN.deguzman.cloud/*=boshi-landing-svc:80,tls=boshi-landing-tls" -n $NAMESPACE
            fi
